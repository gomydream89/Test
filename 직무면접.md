# 1. 지원동기)
## 자기소개
“프로젝트마다 고객에 따라 달라지는 업무 도메인을 탈피하고 다양한 고객을 대상으로 한 자동차 보험 IT 서비스를 개발하며 성취감을 얻고 싶습니다.”

저는 금융 SI 프로젝트(우리은행 글로벌, 국세행정 전편 개편, 나이스디앤비 차세대 시스템 구축) 사업과 제2금융권 여신기업인 롯데캐피탈 운영지원 업무를 총 7년간 수행하였습니다. 그리고 금융 업무 이해도를 높이기 위해 전산회계, 자산관리사(PB)와 같은 금융자격증을 취득하였습니다. 하지만 회사 내 조직 개편으로 인해 더 이상 금융 도메인 사업 수행이 불가능해졌고 그리하여 이번 기회에 프로젝트마다 고객에 따라 달라지는 업무 도메인을 탈피하고 금융 업무의 전문성을 더욱 높이고 싶습니다. 디지털 보험사에 맞게 다양한 사용자를 대상으로 쉽고 접근성 높은 보험 서비스를 개발하여 성취감을 얻고 싶습니다.  

이번 채용을 통해 한정적인 역할을 수행하는 외부 소속원이 아닌 자동차 보험 IT 담당자로서 업무를 주도적으로 수행하여 비즈니스를 완벽히 이해하고 사용자에게 안전하고 신뢰받는 보험 상품을 서비스하는 데에 일조하겠습니다. 

## 자기소개 
자신만의 경쟁력을 말해보아라(프로젝트를 하면서) 
코웍에 대한 강점이 있다고 생각합니다. SI를 수행하며 매 프로젝트에서 뛰어난 적응력을 가지고 실무 담당자, IT 담당자, 유관부서 등 다양한 사람들과 커뮤니케이션하며 협업 능력을 키웠습니다.

두번쨰는 금융 업무 전반에 대한 이해도가 높다고 생각합니다. 금융 SI&SM 프로젝트를 수행하며 실무 이해도를 높혔으며 상품 Rule을 기반으로 한 서비스 개발도 수행하였습니다. 또한  
전산회계와 자산관리사 같은 자격증도 취득하며 금융업에 대한 개념을 숙지하고 있습니다.  

또한 급변하는 기술 환경에 발맞춰 고객 요청에 대해 신속하게 트랜잭션을 지원하고 변경 사항에 대해 효율적이고 생산적인 개발이 가능하도록 지속적으로 자기계발에 힘쓰겠습니다. 
마지막으로 회사 생활 또한, 긍정적이고 쾌활한 성격을 통해 팀에 잘 융화될 수 있다고 자신합니다. 당사에 입사하여 즐거움과 만족감을 느끼며 개발자로 성장하고 싶습니다.

# 2. 주요 업무 경험
현재눈 KT&G Non-Erp 시스템 구축 프로젝트에서 신경작 시스템의 업무 PL을 수행하고 있습니다. 경작이란, 담배의 주원료인 담배잎 농사를 의미하며
계약, 경작 진행, 잎을 수확하는 수매 등 경작 전반의 시스템에 대해 개편을 수행중입니다.

1) CREPORT 나이스 D&B 외부 서비스인 CREPORT 시스템 개편을 PL로서 수행하였습니다. 크레포트는 거래처 기업의 신용. 상태 정보를 제공하고 변동현황을 모니터링하여 리스크관리,부실채권의 발생을 예방하는 기업 신용관리 서비스입니다. 사용자에게 최적화된 시스템 구축을 위해, 거래처 기업 등록 간소화 / 경쟁기업 비교분석과 같은 신규 기능 개발 / 중복 화면 및 기능 제거 등을 중점으로 비즈니스 로직 및 DB를 설계하였습니다.
또한 평가부서에서 도출한 등급 산정요건을 기반으로 기업 신용평가 등급 모형을 시스템화 하였습니다. 단계 별 테스트를 통해 완성도 높은 시스템을 구축하였으며 프로젝트 납기도 준수하였습니다.

프로젝트를 수행하며 요구사항에 무조건적인 수용이 아닌 고객화 협의하고 조율하여 기능의 활용성과 유용성/ 사용자 편의성을 중점으로 시스템을 구축하였습니다.

2) 롯데캐피탈 롯데캐피탈 계정계 오토리스 고도화 사업에 투입되어 리스 품의 및 차량관리 업무를 주도적으로 수행하였습니다. 이후, 오토리스 업무를 운영하며 품의-계약-대출-해지 와 같은 리스 전반의 시스템에 대한 품질 개선을 지원하였습니다. 신규 상품 또는 기존 상품 약관 변경 시에는, 해당 상품 Rule을 기반으로 프로그램을 개발 및 개선하였습니다.
또한 기업 및 개인의 대출의 스케줄 조정,이자 계산, 청구서 발행등의 청구 운영업무도 함께 수행하였습니다. 이외에도 채널계 ANYLINK 솔루션을 이용하여 금융결제원과 전문 송수신을 통한 대외 실시간 계좌 이체 및 수납 기능을 신규로 개발하였습니다.

담당 업무의 유관부서와의 커뮤니케이션을 적극적으로 주도하여 업무를 조율하였으며 이 프로젝트를 통해 금융권 계정계 IT비즈니스 전반에 대해 실무 이해도를 높힐 수 있었습니다.

3) 국세행정시스템 국세청 전면개편 2단계 사업에 투입되어 세원분석 업무 배치 개발을 주도적으로 수행하였습니다. 세원분석은 소득세.증여세 등 세원의 신고 및 해당 자료로부터 불성실 신고자 및 탈루 혐의자를 추출하기 위한 자료를 구축하는 업무입니다.
COBOL언어로 구현된 기존 시스템을 분석 후 재설계 하여 배치를 개발하였습니다. 신고 성실도 전산분석 자료를 생성하였고 세원분석 대상자를 추출하였습니다.

실 운영 데이터를 기반으로한 통합테스트에서, 국민을 대상으로 한 대용량 데이터로 인해 수행시간 초과, 결과 미일치 등의 이슈도 발생하였으나, 이슈 원인과 업무 로직 등 핵심사항에 대해 업무 담당자와 적극적으로 검증하고 수정하여 일정 지연 없이 성공적으로 수행할 수 있었습니다.

4) 우리은행 글로벌 표준시스템 구축 해당 사업에 투입되어, 감사 업무의 대내화면 개발을 주도적으로 수행하였습니다. 또한 금융범죄 및 불법 자금 관련 리스크를 관리하는 AML 업무도 수행하였습니다. 해당 업무에 필요한 운영 데이터를 ETL을 이용하여 추출하여 가공한 뒤 데이터마트에 적재하였습니다.
위 프로젝트는 PL이 3번이나 교체되어 진행의 어려움이 있었지만 PM과 내부 여러 유관부서에 적극적으로 업무 문의와 협조를 요청하여 고객의 요구사항을 정리하고 필수 산출물을 작성하는 등 기본적인 설계가 진행될 수 있도록 커뮤니케이션을 주도하였습니다.

# 3. JVM 동작원리 
## JVM 
 Java Byte Code를 OS에 맞게 해석 해주는 역할
  Java compiler는 .java 파일을 .class 라는 Java byte code로 변환 시켜 줍니다. Byte Code 는 기계어가 아니기 때문에 OS에서 바로 실행되지 않습니다. 
  이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다. Byte Code는 JVM 위에서 OS상관없이 실행된다.
  JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine 3가지로 구성

## Java 프로그램 실행과정
1. 프로그램 실행 시, JVM은 OS으로 부터 이 프로그램이 필요로 하는 메모리를 할당 받고 
   JVM은 이 메로리를 용도에 따라 여러 영억으로 나누어 관리
2. 자바 컴파일러가 자바 소소코드를 읽어들여 자바 바이트코드(.CLASS)로 변환시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 로딩하낟.
4. 로딩된 class파일들은 Excution Engine 을 통해 해석된다.
5. 해석된 바이트코드는 RunTime Data Areas 에 배치되어 실질적인 수행이 이루어지게 된다. 


## JVM 구조
* Class Loader
RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.
* Runtime Data Areas
JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, Runtime Data Areas는 크게 5가지 영역으로 나눌 수 있습니다.
1) Heap 
 - 런타임 시 동적으로 할당하여 사용하는 영역이며, new 연산자로 생성된 객체 외 배열을 저장합니다. 
 - heap 영역에는  크게 permanent geration, new, old 영역으로 나뉩니다. permanent geration 영역에 생성된 객체들의 주소값이 저장됩니다. new 영역은 다시 eden, survivor 영역으로 나뉘어있습니다. eden에는 객체들이 최초로 생성되는 영역이며 suvivor는 eden 영역에서 참조되는 객체들이 저장되는 영역입니다. 마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간입니다. 
 
   - 프로그램 상에서 (class 이용해 instance 생성 시, Heap에 저장)
     new 연산자로 생성된 객체외 배열을 저장. 
     * New(Eden/Survivor) | Old | Permanent 
      permanent geration 영역에 생성된 객체들의 주소값이 저장됩니다. Class Loader에 의해 Load되는 클래스,메소드 등에 대한 Meta 정보가 저장되는 영역.
      new 영역은 다시 eden, survivor 영역으로 나뉘어있습니다. 
      eden에는 객체들이 최초로 생성되는 영역이며 suvivor는 eden 영역에서 참조되는 객체들이 저장되는 영역입니다. 
      마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간입니다. 

      Eden 영역에 객체가 가득차게 되면 첫번째 GC(minor Gc)가 발생되는데, Eden 영역의 값들을 survivor 1영역에 복사하고, 이영역을 제외한 나머지 영역의 객체를 삭제 
       

2) Method Areas(= Static Area)
   - 클래스, 변수, 메소드, 상수, static 변수에 대한 정보의 바이트 코드등을 보관합니다. 
   - 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드등을 보관)
     즉, 클래스 정보를 처음 메모리 공간에 올릴 떄 초기화 되는 대상을 저장하기 위한 메모리 공간. 
3) Native Method Stack
   - Java 외의 언어로 작성된 네이티브 코드들을 위한 저장되는 영역. stack.(JAVA Native Interface를 통해 바이트코드로 전환하여 저장)
     즉, 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역. 
4) Java Virtual Marchine Stack
   - stack 영역에는 메소드 호출에 따른 메소드를 위한 공간인 프레임(frame)이 생성되어 메소드 안에서 필요한 각종 값이 임시로 저장됩니다. 메소드의 수행이 끝나면 프레임별로 삭제가 진행됩니다.
   - Thread의 수행정보를 Frame(메소드만을 위한 공간)을 통해서 저장, Thread가 시작될 떄 생성되며, 각 Thread 별로 생성이 됨.
     임시로 할당 되었다가, 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역. 
     즉 메쏘드가 호출되면서 메쏘드와 몌소드 정보는 stack에 쌓이게 되며, 메쏘드 정보는 해당 메소뜨의 매개변수, 지역변수, 임시변수 그리고 어드레스(메소드 호출 한 주소)드을 저장하고, 메소드 종료 시 메모리 공간 사라진다.
5) PC Register
   - PC 레지스터는 Thread 별로 하나 씩 존재하며(시작될 떄 생성) 
     Thread가 어떤 부분을 명령으로 실행해야 하는 지에 대한 저장을 합니다. 
     현재 수행중인 Java Virtual Marchine Instuction 의 주소를 가지게 된다. 

* Execution Engine 
Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine입니다. 
Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Executin Engine에 의해 실행되며, 
실행 엔진은 자바 바이트 코드를 기계가 실행할 수 있는 형태로 변경하여 
명령어 단위(인터프리터)로 읽어서 실행합니다. 해당 방식은 한 줄 씩 수행하기 떄문에 느리다는 단점이 존재하며
이 단점을 보완하기 위해 도입된 방식은 Just In Time 컴파일러이다.
인터프리터 방식으로 실행하다 적절한 시점에 바이트코드 전체를 컾마일하여 네이티브 코드로 변경하고, 
이후에는 네이티브 코드로 직접 실행

## 메모리관리 
자바에서는 JVM이 프로그램 메모리를 관리한다. JVM은 가비지 컬렉션이란 프로세스를 통해 메모리를 관리하며, 
이 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거한다. 가비지 컬렉션은 실행 중인 JVM 내부에서 일어난다.

1) Minor GC
minor에서는 new 영역(Eden/Survivor)을 대상으로 실행됩니다. 
첫째로 new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제합니다. 
둘째로 eden 영역과 survivor1 영역이 기준치 이상으로 찼을경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 
survivor2 영역에 복사 후 나머지 영역의 객체를 삭제합니다. 마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킵니다.

2) Major GC
major에서는 old 영역을 대상으로 실행됩니다. old 영역에 있는 모든 객체를 검사하여 참조되지 않은 객체들을 한꺼번에 삭제합니다.
minor에 비해 시간이 오래 걸리며 실행 중 프로세스가 정지된다. 이것을 STOP-THE-WORLD라고 하는데 
Major GC가 발생하면 GC를 실행하는 스레드를 제외한 나머지 스레드는 모두 작업을 멈추며, GC 작업을 완료한 이후에야 중단했던
작업을 다시 시작한다. 
old 영역이 가득 차, 프로세스가 정지될 가능성이 있는 경우 실행됩니다. 

## 참고. JDK & JRE
JDK는 자바 개발 키트이다.(JDK: Java Development Kit)
JDK = JVM + 라이브러리 API + 컴파일러
JRE는 자바 실행 환경이다.(JRE: Java Runtime Environment)
JRE = JVM + 라이브러리 API
자바 프로그램을 개발하려면 JDK를 사용하면 되고, 개발된 프로그램을 실행만 한다면 JRE만 설치하면 된다.

# 4. 객체지향의 개념과 Spring 특징
객체지향이란 실세계를 모델링하여 소프트웨어를 개발하는 방법론입니다. 
객체지향의 장점으로는 코드의 재사용성을 극대화시켜 개발 및 유지보수 과정에서 효율적입니다.
객체지향의 3대 특징으로는 추상화, 캡슐화, 상속, 다형성 있습니다. 

1) 추상화 
구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루며, 이 개념은 변수와 메소드를 정의하여 구현합니다. 
각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다.

2) 캡슐화 - 정보 은닉(information hiding)
필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것 클래스 외부에서 불필요한 데이터의 접근을 제한하여 올바른 값을 유지하도록 보호할 수 있습니다.

3) 일반화 관계(상속) - 
여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정 

4) 다형성
서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

* OOP의 5대 원칙(SOLID)
- S: 단일 책임 원칙(SRP, Single Responsibility Principle) 객체는 단 하나의 책임만 가져야 한다. 
- O: 개방-폐쇄 원칙(OCP, Open Closed Principle) 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. 
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle) 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다. 
- I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle) 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다. 
     특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다. 
- D: 의존 역전 원칙(DIP, Dependency Inversion Principle) 구체화(구현클래스)에 의해 의존하지 않고, 추상화(인터페이스)에 의존하여 설계한다. 
     의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.

* AOP란?
관심지향 프로그래밍 기법(AOP, Aspect Oriented Programming) 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법입니다.

* 의존성이란?
의존관계를 가지는 상황 A 클래스가 B 클래스를 내부적으로 사용하는 경우를 말한다. B 클래스가 변경되면 기존의 A클래스에도 영향이 간다. 
이러한 의존성을 줄이기 위해 DI(Dependency Injection)를 사용합니다.

* DI를 해야하는 이유?
DI, 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것이다. 이를 통해 객체간의 결합도를 줄이고 코드의 재활용성을 높여준다.

* IOC에 대해 설명하시오. Inversion of Control
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는것을 의미 즉 제어권을 컨테이너(프레임워크)가 가지며, 객체를 관리,생성을 책임지고, 의존성을 관리합니다.

* PSA(Portable Service Abstraction)
환경의 변화와 관계없이 일관된 방식의 기술 접근 환경을 제공하려는 추상화 구조

* Sprig을 사용하게 되는 목적 요소 
-> 스플링은 IoC와 AOP를 지원하는 의 컨테이너 프레임워크
스프링은 자바 및 JVM 환경의 대체언어들의 효율적이고 쉬운 엔터프라이즈 애플리케이션 개발 환경을 제공한다.
스프링은 만들고자하는 애플리케이션의 요구사항과 목적에 따라 유연하게 적용시킬수 있습니다.
스프링은 패키지들간의 순환 의존성이없는 깨끗한 프로젝트구성을 만들수 있다.
스프링은 직관적인 API를 제공한다.
스프링은 오픈소스로써 지속적인 업데이트가 되고 있으며 이전 버전들에대한 강력한 호환성을 지원한다.
